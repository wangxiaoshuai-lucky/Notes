## mysql（InnoDB）
### 1 数据库ACID
* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）
### 2 事务的隔离级别
|         事务隔离级别          | 脏读  | 不可重复读 | 幻读  |
|:-----------------------:|:---:|:-----:|:---:|
| 读未提交（read-uncommitted）  | 	是  |  	是   | 	是  |
|   读提交（read-committed）   | 	否  |  	是   | 	是  |
| 可重复读（repeatable-read）默认 | 	否  |  	否   | 	是  |
|   串行化（serializable） 	   |  否  |  	否   | 	否  |

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据  
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。  
3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。   
### 3 事务的传播行为
| 事务传播行为类型                    | 说明                                                          |
|-----------------------------|-------------------------------------------------------------|
| PROPAGATION_REQUIRED(默认情况下) | 	如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。            |
| PROPAGATION_SUPPORTS        | 	支持当前事务，如果当前没有事务，就以非事务方式执行。                                 |
| PROPAGATION_MANDATORY       | 	使用当前的事务，如果当前没有事务，就抛出异常。                                    |
| PROPAGATION_REQUIRES_NEW    | 	新建事务，如果当前存在事务，把当前事务挂起。                                     |
| PROPAGATION_NOT_SUPPORTED   | 	以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。                              |
| PROPAGATION_NEVER           | 	以非事务方式执行，如果当前存在事务，则抛出异常。                                   |
| PROPAGATION_NESTED          | 	如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

### 4 数据库锁
* 共享锁（s锁）：共享锁，多个事务共享一行数据，对其读操作，防止其他事务来修改，对其加共享锁。
* 排他锁（x锁）：互斥，当某个事务需要修改某一行，防止其他事务去访问，对其加互斥锁。
* 意向锁：一个事务对一行加锁，另一个事务要对整个表加锁，这时候会遍历每一行是否加锁，效率低下；引入意向锁，在对某一行加锁的时候，首先对整个表请求意向锁，表示这个表中有数据正在加锁，这时候一个事务对整个表加锁，那么首先看看意向锁是否请求成功，如果不成功，表示有数据正在加锁，这时候等待第一个事务完成后解除意向锁和行级锁，那么这时候请求成功，对整个表加锁
### 5 事务的实现原理
在开启事务的时候，每个db操作记录下来，如果提交那么保存到redo日志中，回滚则是写入undo日志中（每个delete对应成一个insert，每个update对应一个反向update），所以当回滚的时候将对应的undo日志写一遍就好
### 6 存储的物理结构和逻辑结构
* .frm文件：表的定义文件
* .idb文件：表的数据文件（数据、索引文件）
分成表空间、段、区、页（存放一批行记录）
### 7 数据类型及其区别
* char：定长，最大255个字符
* varchar：变长，最大65535个字符（既是单列的限制，又是整行的限制）
* text：变长，有字符集的大对象，并根据字符集进行排序和校验，大小写不敏感
* blob：变长，无字符集的二进制大对象，大小写敏感

#### 7.1 varchar和char的区别
区别一：char不可变，varchar可变；varchar（20）表示20个**字符**，4.0以前指的是20个**字节**  
#### 7.2 text和BLOB的区别
text存放字符文本（有字符集），blob存放二进制文件（可保存图片）
### 8 索引分类
* 主键：是一种特殊的唯一索引，不允许有空值。
* 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
* 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
* 复合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
* 全文索引：全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引

### 9 索引实现原理（B+树）
#### 9.1 B+树：  
1. 有k个子结点的结点必然有k个关键码
2. 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中
3. 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录  
#### 9.2 索引结构：
* ***聚集索引***  
一个表只能有一个聚集索引：由主键所建成的B+树构成  
* ***非聚集索引（辅助索引）***  
由每个索引建成的B+树，叶子节点保存的是记录的聚集索引键，也就是说每次通过非聚集索引查找相关记录的时候是查找两个B+树
（有些引擎是非聚集索引直接保存的是记录的磁盘位置，这样的话只需要查找一个B+树，但是记录如果有修改，那么会更新所有的相关聚集索引，
但是如果存放聚集索引键，那么只用更新聚集索引的B+树）  
#### 9.3 复合索引实现原理  
比如（列a，列b）的复合索引：  
建造一个列A的B+树，每个叶子节点存放所有的列a的数据，然后按照列b排序  
例：按照年龄、姓、名字排序  
![三个索引图](./imgs/1.png)  
上述也解释了复合索引为什么是最左匹配原则  
### 10 自适应哈希  
InnoDB存储引擎自动创建一个哈希表，自动根据访问的频率和模式来为某些页建立哈希索引。
### 11 数据库优化
#### 11.1 尽可能不要使用NULL值
* NULL使得索引维护更加复杂
* NULL列需要一个额外字节作为判断是否为NULL的标志位，加大存储空间
* select * from user where name not in ('12',...) 不会返回含有空值的记录
* select * from user where name is null 是会走索引的
#### 11.2 优化查询语句
* 请尽量使用简单的查询，避免使用表链接
* 请尽量避免全表扫描
* 请尽量指定需要查询的列
* 分页查询
#### 11.3 善用索引
* 对常用的查询适当添加索引
* 对组合查询选择适合的顺序
#### 11.4 不设置外键约束
外键约束在更新、插入、删除操作的时候会检查一次，影响执行效率，开发人员在程序中控制
### 12 MyISAM和InnoDB对比
| 功能差异  | MyISAM | InnoDB |
|-------|--------|--------|
| 查询速度  | 快      | 慢      |
| 锁     | 表锁     | 行级锁    |
| 事务    | 不支持    | 支持     |
| 索引和数据 | 分离     | 一起     |
| 外键    | 不支持    | 支持     |
| 全文索引  | 支持     | 不支持    |

MyISAM比InnoDB快的原因：
* INNODB要缓存数据块（数据量大），MYISAM只缓存索引块（数据量小），这中间还有换进换出的减少；
* innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快
* INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护
### 13 MVCC机制
引入意义：锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.  
实现原理：InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的（创建版本号ID，删除版本号ID），select的时候：只有a,b同时满足的记录，才能返回作为查询结果.  
read-view: 事务开始时，记录当时【未提交的事务id列表】、【最小值未提交事务id】、【最大值未提交事务id】   
a.InnoDB只会查找版本早于当前事务版本的数据行 且 不在【未提交事务id列表】，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.  
b.行的删除版本要么未定义,要么大于当前事务版本号 且 不在【未提交事务id列表】,这可以确保事务读取到的行，在事务开始之前未被删除.
### 14 快照读和当前读
当前读：即加锁读，读取记录的最新版本号，会加锁保证其他并发事物不能修改当前记录，直至释放锁。  
快照读：不加锁，读取记录的快照版本，而非最新版本，使用MVCC机制，最大的好处是读取不需要加锁
### 15 主从复制
master配置:  
~~~
server-id=1
log-bin=master-bin
log-bin-index=master-bin.index
~~~
slave:
~~~
server-id=2
relay-log-index=slave-relay-bin.index
relay-log=slave-relay-bin

mysql> change master to master_host='主xxx.xxx.xxx.xx',
master_port=3306,
master_user='user',
master_password='pwd',
master_log_file='master-bin.000001',
master_log_pos=0;

mysql> start slave;
~~~
### hash（散列）和b+树 对比
* 范围查询 hash不支持
* 不支持排序
* Hash索引不能模糊查询