## 操作系统

### 基本功能

* 进程管理
    * 进程调度、同步、死锁处理
* 内存管理
    * 虚拟内存分配、内存置换
* 文件管理
    * 目录管理
    * 文件管理
    * 权限管理
* 设备管理
    * IO设备管理
    * 设备分配

### 并发、并行

* 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
* 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

### 内核态、用户态

* 内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
* 用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取

用户程序如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作

### 进程、线程

* 进程：进程是资源分配的基本单位。
* 线程：线程是独立调度的基本单位，一个进程中可以有多个线程，它们共享进程资源。

区别：

* 拥有资源：进程是资源分配的单位，线程共享进程资源
* 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU
  环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
* 通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

进程通信：

* 管道：ps -ef|grep tomcat
* 信号量：可以用来控制多个进程对共享资源的访问，它常作为一种锁机制。
* 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。
* 套接字(网络通信)：套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

### 多线程和多进程如何选择

* 数据共享：进程独立 \< 线程独立
* 数据同步：进程分开，不需要同步 \> 线程需要做同步
* 内存消耗：进程占用多 \< 线程耗费少
* CPU切换：进程慢 \< 线程快
* 创建销毁：进程慢 \< 线程快
* 调试：调试简单 \> 线程复杂

### 死锁

#### 产生条件

* 互斥
* 不可抢占
* 持有且等待
* 环路等待

#### 死锁检测

假设让完全拥有资源的进程，然后收回资源，继续分配给能运行的进程，如果最后都能运行，就没有死锁，否则有死锁

#### 死锁避免

银行家算法：是否存在一条能正常走完进程的路径。

* 不断满足一个进程，然后收回进程资源
* 如果不能满足任何一个进程，说明状态不安全

### 虚拟内存

分段式或者分页式将用户程序部分载入内存，当某部分内存缺失时，才进行选择性加载。虚拟出一个载入全部内存的假象

### 内存置换算法

* 最佳算法（OPT）理论算法：选择一个未来最长时间不被访问的页面出去
* 最近未使用（LRU）：选择一个最近没被使用的页面出去，置换依据：最近都没被访问的页面在将来可能也不会访问
* 先进先出算法（FIFO）：最先来的最先被替换出去

### select、poll、epoll 对比

IO:

* 阻塞IO
* 非阻塞IO
* 多路复用IO：基于select、poll、epoll实现

select:
一个线程监听所有所有 Socket 句柄(fd_set)，轮训句柄，如果有句柄有数据就会返回，需要轮训 fd_set 检查哪条 fd 数据 ok。

~~~ c
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
~~~

poll:
流程和 select 类似，参数不一致，无数量限制

~~~ c
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
~~~

select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

epoll:
epoll通过注册监听 fd，当 fd 就绪迅速激活这个文件描述符，当进程调用 epoll_wait() 时便得到通知则返回.

~~~
int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；// 注册
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);// 阻塞监听
~~~